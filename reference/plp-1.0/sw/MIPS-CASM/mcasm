#!/usr/bin/perl

# Caesar MIPS Assembler - MCASM
# Simplistic MIPS 2-pass Assembler
# Generates flat object code suitable for FPGAs
# Version 0.0010

# Wira Mulia <wheerdam@gmail.com>
# Licensed under GPLv3

# TODO:
#   imm and shamt fields boundary checks

use constant ORG => 0x0;
use constant RAM => 0x0;

print "MIPS-CASM\n";
print "version 0.0010\n";
print "Wira Mulia <wheerdam\@gmail.com>\n";
print "Licensed under GPLv3\n";

if( @ARGV != 2) {
  print "Usage: mcasm.pl FILE BITFILE\n";
  exit(0);
}

if(-e $ARGV[1]) {
  print "$ARGV[1] already exists. Overwrite? (y to continue) ";
  $_ = <STDIN>;
  chomp;
  print "\n";
  if($_ ne 'y') {
    exit;
  }
}

 $generate_coe=1;                     # set to generate COE file for block RAM
 $generate_irom=1;                    # set to generate ROM entries for verilog
 $parse_directives=1; 
 $suppress_directive_warnings=0; 
 $disallow_multiple_orgs=1;
 $pack_ecen4243=1; 
 $verbose=1;

$opcode{'add'}   = 0x20;
$opcode{'addu'}  = 0x21;
$opcode{'and'}   = 0x24;
$opcode{'jr'}    = 0x8;
$opcode{'nor'}   = 0x27;
$opcode{'or'}    = 0x25;
$opcode{'slt'}   = 0x2a;
$opcode{'sltu'}  = 0x2b;
$opcode{'sll'}   = 0x00;
$opcode{'srl'}   = 0x02;
$opcode{'sub'}   = 0x22;
$opcode{'subu'}  = 0x23;

$opcode{'addi'}  = 0x8;
$opcode{'addiu'} = 0x9;
$opcode{'andi'}  = 0xc;
$opcode{'beq'}   = 0x4;
$opcode{'bne'}   = 0x5;
$opcode{'lui'}   = 0xF;
$opcode{'lw'}    = 0x23;
$opcode{'ori'}   = 0xD;
$opcode{'slti'}  = 0xa;
$opcode{'sltiu'} = 0xb;
$opcode{'sw'}    = 0x2b;

$opcode{'j'}     = 0x2;
$opcode{'jal'}   = 0x3;

# MCASM Directives
$opcode{'__MVAR_WORD__'} = 0xff;
$opcode{'__M_ORG__'} = 0xff;
$opcode{'__M_LI__'} = 0xff;

$type{'j'} = 'j';
$type{'jal'} = 'j';

$type{'add'} = 'r';
$type{'addu'} = 'r';
$type{'and'} = 'r';
$type{'jr'} = 'rjump';
$type{'nor'} = 'r';
$type{'or'} = 'r';
$type{'slt'} = 'r';
$type{'sltu'} = 'r';
$type{'sll'} = 'rshift';
$type{'srl'} = 'rshift';
$type{'sub'} = 'r';
$type{'subu'} = 'r';

$type{'addi'} = 'i2';
$type{'addiu'} = 'i2';
$type{'andi'} = 'i2';
$type{'beq'} = 'ibranch';
$type{'bne'} = 'ibranch';
$type{'lw'} = 'wordop';
$type{'sw'} = 'wordop';
$type{'lui'} = 'i1';
$type{'ori'} = 'i2';
$type{'slti'} = 'i2';
$type{'sltiu'} = 'i2';

$regs{'$0'}  = 0;
$regs{'$1'}  = 1;
$regs{'$2'}  = 2;
$regs{'$3'}  = 3;
$regs{'$4'}  = 4;
$regs{'$5'}  = 5;
$regs{'$6'}  = 6;
$regs{'$7'}  = 7;
$regs{'$8'}  = 8;
$regs{'$9'}  = 9;
$regs{'$10'} = 10;
$regs{'$11'} = 11;
$regs{'$12'} = 12;
$regs{'$13'} = 13;
$regs{'$14'} = 14;
$regs{'$15'} = 15;
$regs{'$16'} = 16;
$regs{'$17'} = 17;
$regs{'$18'} = 18;
$regs{'$19'} = 19;
$regs{'$20'} = 20;
$regs{'$21'} = 21;
$regs{'$22'} = 22;
$regs{'$23'} = 23;
$regs{'$24'} = 24;
$regs{'$25'} = 25;
$regs{'$26'} = 26;
$regs{'$27'} = 27;
$regs{'$28'} = 28;
$regs{'$29'} = 29;
$regs{'$30'} = 30;
$regs{'$31'} = 31;

$regs{'$zero'} = 0;
$regs{'$at'}   = 1;
$regs{'$v0'}   = 2;
$regs{'$v1'}   = 3;
$regs{'$a0'}   = 4;
$regs{'$a1'}   = 5;
$regs{'$a2'}   = 6;
$regs{'$a3'}   = 7;
$regs{'$t0'}   = 8;
$regs{'$t1'}   = 9;
$regs{'$t2'}   = 10;
$regs{'$t3'}   = 11;
$regs{'$t4'}   = 12;
$regs{'$t5'}   = 13;
$regs{'$t6'}   = 14;
$regs{'$t7'}   = 15;
$regs{'$s0'}   = 16;
$regs{'$s1'}   = 17;
$regs{'$s2'}   = 18;
$regs{'$s3'}   = 19;
$regs{'$s4'}   = 20;
$regs{'$s5'}   = 21;
$regs{'$s6'}   = 22;
$regs{'$s7'}   = 23;
$regs{'$t8'}   = 24;
$regs{'$t9'}   = 25;
$regs{'$k0'}   = 26;
$regs{'$k1'}   = 27;
$regs{'$gp'}   = 28;
$regs{'$sp'}   = 29;
$regs{'$fp'}   = 30;
$regs{'$ra'}   = 31;

&info("Assembling $ARGV[0] Pass 1");
$i=0;
$errors=0;
@error_str;
$warnings=0;
@asm_in;
$pseudo_ops;

$addr=ORG;
$alloc_ptr=RAM;
$line_count=0;
%symbols;
$parse_mode='text'; # default to ROM if no directive is found
$org_set = 0;
$org_start = ORG;
@linenummap;
%include_stack;

# First pass
#  you may add custom pre-processing macros here
# make sure you update line number map, address and
# index if you insert/remove macros
$i=0;

&asm_first_pass($ARGV[0]);

printf "\n symtable\n ========\n";
foreach $val (sort {$symbols{$a} cmp $symbols{$b} } keys %symbols) {
    $v_hex = sprintf("%x", $symbols{$val});
    printf "0x$v_hex\t=> $val\n";
}

$i = 0;
$addr = ORG;
$last_error = $errors;

if($errors == 0) {

if( $generate_coe ) {
  open COE, ">$ARGV[1].coe" or die("[E] Unable to open $ARGV[1].coe for writing\n");
  print COE "memory_initialization_radix=2;\n";
  print COE "memory_initialization_vector=\n";
}

if( $generate_irom ) {
  open IROM,">$ARGV[1].rom" or die("[E] Unable to open $ARGV[1].rom for writing\n");
}

open BIT, ">$ARGV[1]" or die("[E] Unable to open $ARGV[1] for writing\n");
binmode BIT;

print "\n[I] Assembling $ARGV[0] Pass 2\n";

foreach( @asm_in ) {
  $addr_hex = sprintf("%.8x", $addr);
  $asm_directive = 0;
  @asm_in[$i] =~ s/^\s+//; #remove leading spaces
  @tokens = split( /,\s+|\s+,|\s+|,/, @asm_in[$i] );
  $j = 0;
  foreach( @tokens ) {
    @tokens[$j] =~ s/^\s+//; #remove leading spaces
    @tokens[$j] =~ s/\s+$//; #remove trailing spaces
    $j++;
  }
  $key = @tokens[0]; 
  
  # validate instructions 
  if( exists $opcode{$key} ) {
    $op_hex = sprintf("%#x", $opcode{$key});
    $instr = $opcode{$key} << 26; #r-type handlers clear this
    $rs=$rt=$rd=$shamt=$imm=0;
    $itype = "---";

    # I-TYPE INSTRUCTIONS #############################################

    # 3-Operand I-type Instructions ###################################

    if( $type{$key} eq 'i2' ) {
      if( !exists $regs{@tokens[1]} || !exists $regs{@tokens[2]} ) {
        print " ---\terr\t@linenummap[$i]: Invalid register\n";
        $errors++;
      } elsif ($#tokens < 3) {
        print " ---\terr\t@linenummap[$i]: Not enough operands\n"; 
        $errors++;
      } else { 
        $s_val = &m_sanitize(@tokens[3]) & 0xffff;
        $instr |= ($imm = $s_val);
        $instr |= (($rt = $regs{@tokens[1]}) << 16);
        $instr |= (($rs = $regs{@tokens[2]}) << 21);
        $shamt=$rd=".";
        $itype="-I-";
      }

    # 2-Operand I-type Instructions ###################################
    
    } elsif ( $type{$key} eq 'i1' ) {
      if( !exists $regs{@tokens[1]} ) {
        print " ---\terr\t@linenummap[$i]: Invalid register\n";
        $errors++;
      } elsif ($#tokens < 2) {
        print " ---\terr\t@linenummap[$i]: Not enough operands\n"; 
        $errors++;
      } else { 
        $s_val = &m_sanitize(@tokens[2]) & 0xffff;
        $instr |= (($imm = $s_val));
        $instr |= (($rt = $regs{@tokens[1]}) << 16);
        $rs=$rd=$shamt=".";
        $itype="-I-";
      }
    
    # Branch I-type Instructions ######################################

    } elsif ( $type{$key} eq 'ibranch' ) {
      if( !exists $regs{@tokens[1]} || !exists $regs{@tokens[2]} ) {
        print " ---\terr\t@linenummap[$i]: Invalid register\n";
        $errors++;
      } elsif ($#tokens < 3) {
        print " ---\terr\t@linenummap[$i]: Not enough operands\n"; 
        $errors++;
      } else { 

        # add boundary check for immediate field here

        if( !exists $symbols{@tokens[3]}) {
          print " ---\terr\t@linenummap[$i]: Bad branch target @tokens[3]\n";
          $errors++;
        } else {
          $branch_target = ($symbols{@tokens[3]} - ($addr + 4)) / 4;
          $imm = $branch_target;
          $instr |= ($branch_target & 0xffff);
          $instr |= (($rt = $regs{@tokens[1]}) << 16);
          $instr |= (($rs = $regs{@tokens[2]}) << 21);
          $rd=$shamt=".";
          $itype="-I-";
        }
      }
    }

    # Word I-type Instructions #############################################
    
    elsif( $type{$key} eq 'wordop' ) {
      @offset_tokens = split /\(/, @tokens[2];
      @offset_tokens[1] = substr @offset_tokens[1], 0, -1;
      if( !exists $regs{@tokens[1]} || 
          !exists $regs{@offset_tokens[1]} ) {
        print " ---\terr\t@linenummap[$i]: Invalid register\n";
        $errors++;
      } elsif ($#tokens < 2 || $#offset_tokens < 1) {
        print " ---\terr\t@linenummap[$i]: Not enough operands\n"; 
        $errors++;
      } else {
        $s_val = &m_sanitize(@offset_tokens[0]);
        $instr |= ($imm = ($s_val & 0xffff));
        $instr |= (($rt = $regs{@tokens[1]}) << 16);
        $instr |= (($rs = $regs{@offset_tokens[1]}) << 21);
        $rd=$shamt=".";
        $itype="-I-";
      }

    # R-TYPE INSTRUCTIONS #############################################

    # 3-Operand R-type Instructions ###################################

    } elsif( $type{$key} eq 'r' ) {
      if( !exists $regs{@tokens[1]} || !exists $regs{@tokens[2]} ||
          !exists $regs{@tokens[3]} ) {
        print " ---\terr\t@linenummap[$i]: Invalid register\n";
        $errors++;
      } elsif ($#tokens < 3) {
        print " ---\terr\t@linenummap[$i]: Not enough operands\n"; 
        $errors++;
      } else {
        $instr = 0; 
        $instr |= (($rd = $regs{@tokens[1]}) << 11);
        $instr |= (($rs = $regs{@tokens[2]}) << 21);
        $instr |= (($rt = $regs{@tokens[3]}) << 16);
        $instr |= $opcode{$key};
        $shamt=$imm=".";
        $itype="R--";
      }

    # Shift R-type Instructions ######################################

    } elsif( $type{$key} eq 'rshift' ) {
      if( !exists $regs{@tokens[1]} || !exists $regs{@tokens[2]} ) { 
        print " ---\terr\t@linenummap[$i]: Invalid register\n";
        $errors++;
      } elsif ($#tokens < 3) {
        print " ---\terr\t@linenummap[$i]: Not enough operands\n"; 
        $errors++;
      } else {
        $instr = 0; 
        $instr |= $opcode{$key};
        $instr |= (($shamt = @tokens[3] & 0x1f) << 6);
        $instr |= (($rd = $regs{@tokens[1]}) << 11);

        # do we use rt or rs here?
        $instr |= (($rt = $regs{@tokens[2]}) << 16);
        $rs=$imm=".";
        $itype="R--";
      }

    # Jump R-type Instructions ###################################

    } elsif( $type{$key} eq 'rjump' ) {
      if( !exists $regs{@tokens[1]} ) {
        print " ---\terr\t@linenummap[$i]: Invalid register\n";
        $errors++;
      } else {
        $instr = 0; 
        $instr |= (($rs = $regs{@tokens[1]}) << 21);
        $instr |= $opcode{$key};
        $rt=$rd=$imm=".";
        $itype="R--";
      }

    # Jump Instructions #############################################

    } elsif( $type{$key} eq 'j' ) {
      if( !exists $symbols{@tokens[1]} ) {
        print " ---\terr\t@linenummap[$i]: Invalid jump target '@tokens[1]'\n";
        $errors++;
      } elsif( exists $symbols{@tokens[1]} ) {
        $instr = 0;
        $imm = $jump_target = $symbols{@tokens[1]} >> 2; 
        $instr |= ($jump_target & 0x3FFFFFF);
        $instr |= ($opcode{$key} << 26);
        $rs=$rt=$rd=$shamt=".";
        $itype="--J";
      }
    } 

    # Data ##########################################################

    elsif ( $key eq "__MVAR_WORD__" ) {
      @tokens[1] = &m_sanitize(@tokens[1]);
      $instr = @tokens[1];
      $itype = 'WORD';
      $rs=$rd=$rt=$shamt=$key=$op_hex='.';
      $imm='';
      for($k = 0; $k < 4; $k++) {
        $imm = $imm.".".sprintf('%c', @tokens[1] & 0xff);
        @tokens[1] = @tokens[1] >> 8; 
      }
    }

    elsif ( $key eq "__M_ORG__" ) {
      $asm_directive = 1;
      $addr = @tokens[1] - 4;
      $line_count--;
    }

    else {
      print " ---\terr\t@linenummap[$i]: Can not parse : @asm_in[$i]\n";
    }

    $addr += 0x4; #advance asm PC 
  }

  else {
    print " err\t@linenummap[$i]: Failed to hash $key,";
    print " blame assembler author : @asm_in[$i]\n";
    $errors++;
  }

  if( $i == 0 || ( $i % 20 == 0 && $asm_directive == 0 )) {
    print "\n addr(hex)\tinstr(hex)\ttype\tid\top/fnct\trs\trt\trd\tshamt\t.\timm\n";
    print   " ---------\t----------\t----\t--\t-------\t--\t--\t--\t-----\t \t---\n";
  }


  # if there's no error, append $instr to bit file 
  if($last_error == $errors && $asm_directive == 0) {
    print BIT pack("N", $instr);
    $instr_hex = sprintf("%.8x", $instr);
    if( $pseudo_ops[$i] == 1 ){
      $itype = $itype."^";
    } elsif ( $pseudo_ops[$i] == 2 ) {
      $itype = $itype."v";
    }
    print " $addr_hex\t$instr_hex\t$itype\t$key\t$op_hex\t";
    print "$rs\t$rt\t$rd\t$shamt\t.\t$imm\n";
    
    # append COE file
    if($generate_coe && $asm_directive == 0) {
      $radix2_instr = sprintf("%.32b", $instr);
      print COE "$radix2_instr";
      if($i == $#asm_in) {
        print COE ";\n";
      } else {
        print COE ",\n";
      }
    }

    # append IROM file 
    if($generate_irom && $asm_directive == 0) {
      $radix2_instr = sprintf("%.32b", $instr);
      print IROM ($line_count),":\tidata = 32'b";
      print IROM $radix2_instr,";\n";
    }
  }

  $line_count++;
  $i++;
  $last_error = $errors;  
}
} #end error check

if($errors > 0) {
  print "\n[I] Assembly failed. $warnings warning(s). $errors error(s) encountered.\n";
  foreach( @error_str ) {
    print $_;
  }
} else {
  print "\n[I] Assembly complete. $warnings warnings.\n";
  if($generate_coe == 1) {
    &info("$ARGV[1].coe written.");
  }
  if($generate_irom == 1) {
    &info("$ARGV[1].rom written.");
  }
  close(IROM);
  close(COE);
  close(BIT);

  if( $pack_ecen4243 && $disallow_multiple_orgs && $generate_coe && $generate_irom ) {
    &info("Packaging PLP metabinary");
    open HEADER, ">header.mcasm" or die("Can not generate header file for ECEN 4243\n");
    print HEADER "$org_start\n";
    print HEADER "$ARGV[1]\n";
    print HEADER "-\n";
    @s_files = keys %include_stack;
    foreach ( @s_files ) {
      print HEADER "$_\n";
    }
    close(HEADER);
    system("tar cf $ARGV[1].plp $ARGV[1] $ARGV[1].coe $ARGV[1].rom header.mcasm @s_files");
    #get rid of the generated files (except for the plp of course)
    unlink "$ARGV[1]", "$ARGV[1].coe", "$ARGV[1].rom", "header.mcasm";
  }
}

sub m_sanitize {
  my $num = @_[0];
  if( (substr $num,0,2) eq '0x' ) {
    return hex($num); 
  }
  else {
    return $num;
  }
} 

# first pass subroutine 
sub asm_first_pass {
  local(*ASM);
  open ASM, "<@_[0]" or die("[E] Unable to open @_[0]\n");
  $include_stack{@_[0]} = 1;

  my $linenum = 1;
  my $label_only = 1;
  my $is_label = 0;

  while( <ASM> ) {
    chomp;
    my $line = $_;
    $line =~ s/^\s+//; #remove leading spaces
    my @tokens = split( /,\s+|\s+,|\s+|,/, $line );
    $j = 0;
    foreach( @tokens ) {
      @tokens[$j] =~ s/^\s+//; #remove leading spaces
      @tokens[$j] =~ s/\s+$//; #remove trailing spaces
      $j++;
    }
    my $key = @tokens[0]; 
  
    $addr_hex = sprintf("%x", $addr);
    my $label_only = 1;
    my $is_label = 0;
  
    # detect labels
    my $colon = substr @tokens[0], -1, 1;
    if( $colon eq ':' ) {
      $key = substr @tokens[0], 0, -1;
      $is_label = 1;
      if( exists $symbols{$key} ) {
        $errors++;
        @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): Symbol '$key' is already defined.\n";
      }
      $symbols{$key} = $addr;
      if( $#tokens > 0 ) { #if we have more tokens in-line with the label, shift the array
        shift @tokens;
        $key = @tokens[0];
        $label_only = 0;
      }
    }

    # allocate variables with .data directive
    if( $parse_mode eq 'data' ) {
      if( $key eq '.word' ) {
        &info("@_[0]($linenum): Initializing $key ($symbols{$key}) to @tokens[1] "); 
        @linenummap[$i] = $linenum;
        @linenummap[$i+1] = $linenum;
        if( $#tokens > 0 ) {
          @linenummap[$i+2] = $linenum;
          $s_val = &m_sanitize(@tokens[1]);
          $upper = $s_val >> 16;
          $lower = $s_val & 0xffff;
          @asm_in[$i] = "lui \$at,$upper";
          @asm_in[$i+1] = "ori \$at,\$at,$lower";
          @asm_in[$i+2] = "sw \$at,$alloc_ptr(\$0)";
          $pseudo_ops[$i] = $pseudo_ops[$i+1] = $pseudo_ops[$i+2] = 2;
          &info(" - @asm_in[$i] ; @asm_in[$i+1] ; @asm_in[$i+2]", 1);
          $i += 3;
          $addr += 3 * 0x4;
        }  
        $alloc_ptr += 0x4;
      }
      &info("");
    }

    # validate instructions
    elsif( exists $opcode{$key} ) {

      # this is a chance to replace some weird instructions

      # gcc style jump register (j $reg instead of j label)
      if( $key eq 'j' && exists $regs{@tokens[1]} ) {
        &info("@_[0]($linenum): 0x$addr_hex $line =>");
        @asm_in[$i] = "jr @tokens[1]";
        print " @asm_in[$i]\n";
        $pseudo_ops[$i] = 1;
      }

      else { # if we get here, the instruction is supported as-is,
             # append it to the instruction array for 2nd pass

        for($j = 0; $j <= $#tokens; $j++) {
          @asm_in[$i] .= @tokens[$j] . " ";
        }
      }

      $parse_mode = 'text';
      @linenummap[$i] = $linenum;
      $addr += 0x4;
      $i++;
    }

    # ignore comments
    elsif( (substr @tokens[0], 0, 1) eq '#' ) {
      #&info("$line");
    }

    ### ADD PRE-PROCESSORS HERE
    # this section handles macros in the assembly file 

    # NOP handler
    elsif( $key eq 'nop' ) {
      @linenummap[$i] = $linenum;
      @asm_in[$i] = "sll \$0,\$0,0"; #replace nop with 0x0
      &info("@_[0]($linenum): 0x$addr_hex nop => @asm_in[$i]");
      $addr += 0x4;
      $pseudo_ops[$i] = 1;
      $i++;
    }

    # branch always pseudo-instruction
    elsif( $key eq 'b' ) {
      @linenummap[$i] = $linenum;
      &info("@_[0]($linenum): 0x$addr_hex $line =>");
      @asm_in[$i] = "beq \$0,\$0,@tokens[1]"; #implement b pseudo-instr
      print " @asm_in[$i]\n";
      $addr += 0x4;
      $pseudo_ops[$i] = 1;
      $i++;
    }

    # move pseudo-instruction
    elsif( $key eq 'move' ) {
      @linenummap[$i] = $linenum;
      &info("@_[0]($linenum): 0x$addr_hex $line =>");
      @asm_in[$i] = "add @tokens[1],\$0,@tokens[2]"; #implement move pseudo-instr
      print " @asm_in[$i]\n";
      $addr += 0x4;
      $pseudo_ops[$i] = 1;
      $i++;
    }

    # load immediate pseudo-instruction
    
    # keep in mind that macros and symbol tables are handled in first
    # pass, so if you do a load immediate macro of a pointer using the
    # label, you have to do it after the label is resolved to an address.

    # future fix may move this to 2nd pass, so it is possible to use
    # load immediate macro of a pointer that has not been resolved.

    elsif( $key eq 'li' ) {
      if( $#tokens < 2 ) {
        $errors++;
        @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): 'li' encountered, but it has invalid number of operands.\n";
      } else {
        @linenummap[$i] = $linenum;   # map the new two instructions to the same line number on .s file
        @linenummap[$i+1] = $linenum;
        if( exists $symbols{@tokens[2]} ) {
          $s_val = $symbols{@tokens[2]};
        } else {
          $s_val = &m_sanitize(@tokens[2]);
        }
        if( !&bound_check($s_val, 32) ) {
          $errors++;
          @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): $s_val is not a valid 32-bit signed integer.\n";
        } else {
          &info("@_[0]($linenum): 0x$addr_hex $line =>", 1);
          $upper = $s_val >> 16;
          $lower = $s_val & 0xffff;
          @asm_in[$i] = "lui @tokens[1],$upper";
          @asm_in[$i+1] = "ori @tokens[1],@tokens[1],$lower";
          &info(" @asm_in[$i] ; @asm_in[$i+1]");
          $addr += 0x8;
          $pseudo_ops[$i] = 1;
          $pseudo_ops[$i+1] = 1;
          $i += 2;
        }
      }
    }

    # directives - this section handles directives in the assemby file.
    elsif( (substr $key, 0, 1) eq '.' ) {
      if( $parse_directives ) {
        if( $key eq '.data' ) {
          $parse_mode = 'data';
        }
        elsif( $key eq '.text' ) { 
          $parse_mode = 'text'; 
        }
        # org- move assembler pointer to the specified address
        elsif( $key eq '.org' ) {
          if( $#tokens < 1 ) {
            $errors++;
            @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): No argument for '$key' directive.\n";
          } elsif ( $org_set ) {
            $errors++;
            @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): Multiple ORGs statement not allowed.\n";
          } else {
            &info("@_[0]($linenum): moving address pointer to @tokens[1]");
            $addr = &m_sanitize(@tokens[1]);
            $alloc_ptr = $addr;
            @asm_in[$i] = "__M_ORG__ $addr";
            $i++;
            $org_start = ( ! $org_set ) ? $addr : $org_start; 
            $org_set = ( $disallow_multiple_orgs ) ? 1 : 0;
          }
        }
        
        # assume flat memory model variable if programmer
        # allocates variable without .data directive

        # .ascii handler
        elsif( $key eq '.ascii' || $key eq '.asciiz') {
          if( $#tokens < 1 ) {
            $errors++;
            @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): No argument for '$key' directive.\n";
          } else {
            @fields = ( $label_only ) ? split(/\s+/, $line, 2) : split(/\s+/, $line, 3);
            $str = ( $label_only ) ? @fields[1] : @fields[2];
            $str =~ s/^"|^'//; # remove leading and trailing quotes/double quotes
            $str =~ s/"$|'$//;
            $str =~ s/\\n/\n/;
            $str = sprintf("%s", $str);
            if( $key eq '.asciiz' ) {
              $str .= pack("i", 0);
            }
            &info("@_[0]($linenum): ASCII string '$str'");
            @chars = split //, $str;
            for($k = 0; $k <= $#chars; $k++) {
              if($k != 0 && $k % 4 == 0) {
                @asm_in[$i] = '__MVAR_WORD__ 0x'.@asm_in[$i];
                $i++;
                $addr += 0x4;
                $alloc_ptr += 0x4;
              }
              $charhex = sprintf("%.2x", ord @chars[$k]);
              @asm_in[$i] = $charhex.@asm_in[$i];
            }
            @asm_in[$i] = '__MVAR_WORD__ 0x'.@asm_in[$i];
            $i++;
            $addr += 0x4;
            $alloc_ptr += 0x4;
          }
        }
        # .space handler (takes number of words to be reserved)
        elsif( $key eq '.space' ) {
          if( $#tokens < 1 ) {
            $errors++;
            @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): No argument for '$key' directive.\n";
          } else {
            for($k = 0; $k < @tokens[1]; $k++) {
              @asm_in[$i] = '__MVAR_WORD__ 0';
              $i++;
              $addr += 0x4;
              $alloc_ptr += 0x4;
            }
          }
        }
        elsif( $key eq '.word' ) {
          &info("@_[0]($linenum): Allocating 32-bit word '$key' at $alloc_ptr", 1);
          $alloc_ptr += 0x4;
          $addr += 0x4;
          $s_val = 0;
          if( $#tokens > 0 ) {
            &info(" : initialized to @tokens[1]", 1);
            $s_val = &m_sanitize(@tokens[1]);
          } 
          @asm_in[$i] = "__MVAR_WORD__ $s_val";
          &info("");
          $i++;
        }

        #.include support
        elsif( $key eq '.include' ) {
          if( $#tokens < 1 ) {
            $errors++;
            @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): No argument for '$key' directive.\n";
          } elsif ( exists $include_stack{@tokens[1]} ) {
            $errors++;
            @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): Recursive include.\n";
          } else {
            &info("@_[0]($linenum): Including @tokens[1] >>>");
            &asm_first_pass(@tokens[1]); # recursively pre-process included .asm
            &info("<<< Parsing of @tokens[1] completed.");
          }
        }

        elsif( $suppress_directive_warnings != 1 ){ 
          &info("@_[0]($linenum): No handler for '$key' directive.");
        }
      } else {} #end directive procesing block
    } #end preprocesing block

    # avoid error messages on empty lines and lines with only a label
    elsif( $line eq "" || ( $is_label && $label_only ) ) {}

    # if we get to this point, something's wrong with the .asm file. Typo? Missing pound
    # for comments?
    elsif( $line ne "" && substr($key, 0, 1) ne '#' ) {
      $errors++;
      @error_str[$errors-1] = "[E] @_[0]($linenum): Error ($errors): Unable to handle token ";
      @error_str[$errors-1] .= "'$key' in '$line'\n";
    } 

    # uh oh, something's really wrong if we get down to this point
    else {
      $errors++;
      @error_str[$errors-1] = "[E] @_[0]($linenum): Failed to pre-process '$line', this is a BUG.";
      @error_str[$errors-1] .= " Contact assembler author.\n";
    }
    $linenum++;
  } #end while

  close(ASM);
  delete @asm_in[$i];
}

sub info {
  my $str;
  if( $verbose ) {
    $str = "- ".@_[0];
    $str .= ( @_[1] ) ? '' : "\n"; 
    print $str;
  }
} 

sub bound_check {
  my $num = @_[0];
  $num = $num >> 31 ? $num - 2**@_[1] : $num;
  if($num >= 2**(@_[1] - 1) || $num < -2**(@_[1] - 1)) {
    return 0;
  } else {
    return 1;
  }
}

# Smile :)
